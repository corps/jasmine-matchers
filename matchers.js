// Generated by CoffeeScript 1.4.0
(function() {

  beforeEach(function() {
    return this.addMatchers({
      toBeCloseTo: function(expected, variance) {
        return this.actual >= expected * (1 - variance) && this.actual <= expected * (1 + variance);
      },
      toHaveCalled: function(spy, method) {
        var count;
        if (method == null) {
          method = null;
        }
        if ((method != null) && typeof method === "string" && !(spy[method].callCount != null)) {
          spyOn(spy, method);
          spy = spy[method];
        }
        this.message = function() {
          return ["Expected " + jasmine.pp(spy) + " to have been called", "Expected " + jasmine.pp(spy) + " not to have been called"];
        };
        count = spy.callCount;
        this.actual.apply(jasmine.getEnv().currentSpec);
        return spy.callCount > count;
      },
      toHaveCalledWith: function(spy, method) {
        var args, count,
          _this = this;
        if (method == null) {
          method = null;
        }
        args = Array.prototype.slice.apply(arguments, [1]);
        if ((method != null) && typeof method === "string" && !(spy.callCount != null)) {
          if (!(spy[method].callCount != null)) {
            spyOn(spy, method);
          }
          spy = spy[method];
          args = Array.prototype.slice.apply(arguments, [2]);
        }
        if (spy.callCount == null) {
          throw "Must provide a spy!";
        }
        count = spy.callCount;
        this.actual.apply(jasmine.getEnv().currentSpec);
        this.message = function() {
          if (spy.mostRecentCall && spy.callCount > count) {
            return ["Expected " + jasmine.pp(spy) + " to have been called with " + jasmine.pp(args) + " but received " + jasmine.pp(spy.mostRecentCall.args), "Expected " + jasmine.pp(spy) + " not to have been called with " + jasmine.pp(args) + " but it did receive " + jasmine.pp(spy.mostRecentCall.args)];
          } else {
            return ["Expected " + jasmine.pp(spy) + " to have been called", "Expected " + jasmine.pp(spy) + " not to have been called"];
          }
        };
        return spy.callCount > count && _.all(_.zip(spy.mostRecentCall.args, args), function(v) {
          return _this.env.equals_(v[0], v[1]);
        });
      },
      toRaiseAnError: function() {
        try {
          this.actual.apply(jasmine.getEnv().currentSpec);
        } catch (e) {
          return true;
        }
        this.message = function() {
          return "Expected function " + jasmine.pp(this.actual) + " to raise error, but it did not";
        };
        return false;
      },
      toChange: function(base, attr, to) {
        var f, previous, val, wrappedF;
        if (attr == null) {
          attr = null;
        }
        if (to == null) {
          to = null;
        }
        if (typeof base !== "function") {
          f = function() {
            return base[attr];
          };
        } else {
          f = base;
          to = attr;
        }
        wrappedF = function() {
          return f.apply(jasmine.getEnv().currentSpec);
        };
        previous = wrappedF();
        this.actual.apply(jasmine.getEnv().currentSpec);
        val = wrappedF();
        this.message = function() {
          if (to != null) {
            return ["Expected value " + jasmine.pp(previous) + " to have changed to " + jasmine.pp(to) + " but it is " + jasmine.pp(val), "Expected value " + jasmine.pp(previous) + " not to have changed to " + jasmine.pp(to) + " but it is " + jasmine.pp(val)];
          } else {
            return ["Expected value " + jasmine.pp(previous) + " to have changed", "Expected value " + jasmine.pp(previous) + " not to have changed but now it is " + jasmine.pp(val)];
          }
        };
        if (!!this.env.equals_(val, previous)) {
          return false;
        }
        if (!((to != null) && !this.env.equals_(to, val))) {
          return true;
        }
      }
    });
  });

}).call(this);
